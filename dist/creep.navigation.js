// Generated by CoffeeScript 2.3.1
var DynamicCreepShuffleGraph, MAX_STUCK_CNT, RoomNavigation, adjacencyOffset, coordToN, dijstraSlowDynamic, dumpPath, dumpVertex, geographyAndStructuresArePassable, hasRoadOn, initializeCreepPath, isAdjacentPosition, isEqualPosition, isFarFromTarget, isNearTarget, isPassableThisTurn, isPathUpToDate, isRetainingTarget, isWallAt, log, nToCoord, nextMoveInstruction, path, positionPassableThisTurn, roomHasRoadOn, updateNavigationPath, updatePositionInPath;

log = require('tools.log');

({coordToN, nToCoord, adjacencyOffset} = require('tools.coordinates'));

({dijstraSlowDynamic, path} = require('tools.adt.graph'));

MAX_STUCK_CNT = 2;

Creep.prototype.moveToTarget = function() {
  var moveInstruction;
  if (this.fatigue > 0 || this.spawning || !(isFarFromTarget(this))) {
    if (typeof log.info === "function") {
      log.info(`${this.name} is fiiine, dude, no need to move.`);
    }
    return;
  }
  updateNavigationPath(this);
  moveInstruction = nextMoveInstruction(this);
  if (moveInstruction != null) {
    if (typeof log.info === "function") {
      log.info(`${this.name} will try moving from ${JSON.stringify(this.pos)} to ${JSON.stringify(moveInstruction)}`);
    }
    return this.room.navigation.attemptMoveToAdjacent(this, this.room.getPositionAt(moveInstruction.x, moveInstruction.y));
  }
};

updateNavigationPath = function(creep) {
  var base, navData;
  navData = (base = creep.memory)._navigationData != null ? base._navigationData : base._navigationData = {
    path: [],
    stuckCounter: 0
  };
  updatePositionInPath(creep, navData);
  if (!(isPathUpToDate(creep.pos, navData.path)) || navData.stuckCounter >= MAX_STUCK_CNT) {
    if (typeof log.info === "function") {
      log.info(`${creep.name}'s stuck or nav cache is incorrect, searching for path to target.`);
    }
    return initializeCreepPath(creep, navData);
  }
};

nextMoveInstruction = function(creep) {
  var ref;
  return _.first((ref = creep.memory._navigationData) != null ? ref.path : void 0);
};

initializeCreepPath = function(creep, navData) {
  navData.path = creep.pos.findPathTo(creep.target, {
    range: creep.targetDistance,
    ignoreCreeps: navData.stuckCounter < MAX_STUCK_CNT
  });
  return navData.stuckCounter -= 1;
};

isFarFromTarget = function(creep) {
  return (creep.target != null) && !creep.pos.inRangeTo(creep.target, creep.targetDistance);
};

isPathUpToDate = function(currentPos, path) {
  return path.length > 0 && isAdjacentPosition(currentPos, path[0]);
};

isEqualPosition = function(posA, posB) {
  return posA.x === posB.x && posA.y === posB.y;
};

isAdjacentPosition = function(posA, posB) {
  return (Math.max(Math.abs(posA.x - posB.x), Math.abs(posA.y - posB.y))) <= 1;
};

updatePositionInPath = function(creep, navData) {
  var results;
  if ((navData.prevPos != null) && (isEqualPosition(creep.pos, navData.prevPos))) {
    navData.stuckCounter += 1;
  }
  navData.prevPos = creep.pos;
  results = [];
  while (navData.path.length > 0 && isEqualPosition(navData.path[0], creep.pos)) {
    if (typeof log.info === "function") {
      log.info(`${creep.name} skips already traversed ${JSON.stringify(navData.path[0])}`);
    }
    results.push(navData.path.shift());
  }
  return results;
};

Object.defineProperty(Room.prototype, 'navigation', {
  get: function() {
    return this._navigation != null ? this._navigation : this._navigation = new RoomNavigation(this);
  },
  enumerable: false
});

RoomNavigation = class RoomNavigation {
  constructor(room1) {
    var creep, i, len, ref;
    this.room = room1;
    this.nextPlaceOfCreep = {};
    this.scheduledNextOccupant = {};
    this.creeps = this.room.find(FIND_MY_CREEPS);
    ref = this.creeps;
    for (i = 0, len = ref.length; i < len; i++) {
      creep = ref[i];
      this.markNext(creep, creep.pos);
    }
  }

  markNext(creep, pos) {
    var status;
    this.nextPlaceOfCreep[creep.name] = pos;
    this.scheduledNextOccupant[coordToN(pos)] = creep;
    status = creep.move(creep.pos.getDirectionTo(pos.x, pos.y));
    if (status !== OK) {
      return new Error(`move of ${creep.name} failed with status = ${status}.`);
    }
  }

  vacatePlaceOf(creep) {
    delete this.scheduledNextOccupant[coordToN(this.nextPlaceOfCreep[creep.name])];
    return delete this.nextPlaceOfCreep[creep.name];
  }

  shuffleCreepsOnPath(creepToMove, shufflePath) {
    var nextCreep, place, results;
    results = [];
    while ((place = shufflePath.pop()) != null) {
      nextCreep = this.scheduledNextOccupant[place.label];
      if (typeof log.info === "function") {
        log.info(`moving ${creepToMove.name} to ${JSON.stringify(nToCoord(place.label))}`);
      }
      this.markNext(creepToMove, nToCoord(place.label));
      results.push(creepToMove = nextCreep);
    }
    return results;
  }

  attemptMoveToAdjacent(creep, nextPos) {
    var dist, graph, posVertex, startVertex, verticesParent;
    if (typeof log.info === "function") {
      log.info(`${creep.name} tries moving through ${JSON.stringify(nextPos)}.`);
    }
    this.vacatePlaceOf(creep);
    graph = new DynamicCreepShuffleGraph(this.room, this.scheduledNextOccupant);
    startVertex = graph.vertex(nextPos);
    posVertex = dijstraSlowDynamic(startVertex, graph.cost, graph.isEmptyPos, dist = {}, verticesParent = {});
    if (posVertex == null) {
      log.error(`Cannot shuffle others so that ${creep.name} can move!`);
      return;
    }
    if (typeof log.info === "function") {
      log.info(`creeps shuffle path ok - place ${dumpVertex(posVertex)} is free!`);
    }
    return this.shuffleCreepsOnPath(creep, path(posVertex, verticesParent));
  }

};

DynamicCreepShuffleGraph = class DynamicCreepShuffleGraph {
  constructor(room1, positionToOccupant) {
    this.room = room1;
    this.positionToOccupant = positionToOccupant;
    this._cachedVertices = {};
    this.cost = (fv, tv) => {
      return this.calculateVertexCost(fv, tv);
    };
    this.isEmptyPos = (v) => {
      return this.positionToOccupant[v.label] == null;
    };
  }

  vertex(pos) {
    var base, positionLabel;
    positionLabel = coordToN(pos);
    return (base = this._cachedVertices)[positionLabel] != null ? base[positionLabel] : base[positionLabel] = {
      label: positionLabel,
      adjacent: this.nextCreepPossibilities(positionLabel)
    };
  }

  calculateVertexCost(fv, tv) {
    var creep, nextInstr, x, y;
    creep = this.positionToOccupant[fv.label];
    ({x, y} = nToCoord(tv.label));
    if (!(isRetainingTarget(creep, x, y))) {
      return 20;
    }
    nextInstr = nextMoveInstruction(creep);
    if ((nextInstr != null) && isEqualPosition(nextInstr, {x, y})) {
      return 0;
    }
    if ((nextInstr != null) && isAdjacentPosition(nextInstr, {x, y})) {
      if (hasRoadOn(this.room, x, y)) {
        return 0.5;
      } else {
        return 1;
      }
    }
    if (hasRoadOn(this.room, x, y)) {
      return 1.5;
    }
    return 2;
  }

  nextCreepPossibilities(positionLabel) {
    return () => {
      var creep, dx, dy;
      creep = this.positionToOccupant[positionLabel];
      return _.compact(((function() {
        var i, len, results;
        if (creep == null) {
          return [];
        } else {
          results = [];
          for (i = 0, len = adjacencyOffset.length; i < len; i++) {
            [dx, dy] = adjacencyOffset[i];
            results.push(this.feasibleNextPosition(creep, dx, dy));
          }
          return results;
        }
      }).call(this)));
    };
  }

  feasibleNextPosition(creep, dx, dy) {
    var x, y;
    [x, y] = [creep.pos.x + dx, creep.pos.y + dy];
    if ((0 <= x && x < 49) && (0 <= y && y < 49) && (positionPassableThisTurn(this.room, x, y))) {
      return this.vertex({x, y});
    }
  }

};

// FIXME: immobile or hostile creeps?
positionPassableThisTurn = function(room, x, y) {
  return isPassableThisTurn(room, x, y);
};

isRetainingTarget = function(creep, x, y) {
  return !(isNearTarget(creep)) || (creep.target.pos.inRangeTo(x, y, creep.targetDistance));
};

dumpVertex = function(posVertex) {
  return JSON.stringify(nToCoord(posVertex.label));
};

dumpPath = function(posVertex, verticesParent) {
  var s;
  return JSON.stringify((function() {
    var i, len, ref, results;
    ref = (path(posVertex, verticesParent)).reverse();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      s = ref[i];
      results.push(nToCoord(s.label));
    }
    return results;
  })());
};

isPassableThisTurn = function(room, x, y) {
  var base, name;
  return (base = (room._isPassableThisTurn != null ? room._isPassableThisTurn : room._isPassableThisTurn = {}))[name = coordToN({x, y})] != null ? base[name] : base[name] = geographyAndStructuresArePassable(room, x, y);
};

hasRoadOn = function(room, x, y) {
  var base, name;
  return (base = (room._hasRoadOn != null ? room._hasRoadOn : room._hasRoadOn = {}))[name = coordToN({x, y})] != null ? base[name] : base[name] = roomHasRoadOn(room, x, y);
};

roomHasRoadOn = function(room, x, y) {
  var i, len, ref, s;
  ref = room.lookForAt(LOOK_STRUCTURES, x, y);
  for (i = 0, len = ref.length; i < len; i++) {
    s = ref[i];
    if (s.structureType === STRUCTURE_ROAD) {
      return true;
    }
  }
  return false;
};

isWallAt = function(room, x, y) {
  var base, base1, name;
  return (base = ((base1 = room.memory)._isWallAt != null ? base1._isWallAt : base1._isWallAt = {}))[name = coordToN({x, y})] != null ? base[name] : base[name] = (room.lookForAt(LOOK_TERRAIN, x, y))[0] === 'wall';
};

geographyAndStructuresArePassable = function(room, x, y) {
  var i, len, ref, s;
  if (isWallAt(room, x, y)) {
    return false;
  }
  ref = room.lookForAt(LOOK_STRUCTURES, x, y);
  for (i = 0, len = ref.length; i < len; i++) {
    s = ref[i];
    if (_.includes(OBSTACLE_OBJECT_TYPES, s.structureType)) {
      return false;
    }
  }
  return true;
};

isNearTarget = function(creep) {
  return (creep.target != null) && creep.pos.inRangeTo(creep.target, creep.targetDistance);
};
